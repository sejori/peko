{
  "version": 3,
  "sources": ["../../../node_modules/preact/src/constants.js", "../../../node_modules/preact/src/util.js", "../../../node_modules/preact/src/options.js", "../../../node_modules/preact/src/create-element.js", "../../../node_modules/preact/src/component.js", "../../../node_modules/preact/src/diff/props.js", "../../../node_modules/preact/src/create-context.js", "../../../node_modules/preact/src/diff/children.js", "../../../node_modules/preact/src/diff/index.js", "../../../node_modules/preact/src/render.js", "../../../node_modules/preact/src/clone-element.js", "../../../node_modules/preact/src/diff/catch-error.js", "../../../node_modules/htm/dist/htm.module.js", "../../../node_modules/htm/preact/index.module.js", "../src/components/Layout.ts", "../src/pages/Home.ts"],
  "sourcesContent": ["/** Normal hydration that attaches to a DOM tree but does not diff it. */\nexport const MODE_HYDRATE = 1 << 5;\n/** Signifies this VNode suspended on the previous render */\nexport const MODE_SUSPENDED = 1 << 7;\n/** Indicates that this node needs to be inserted while patching children */\nexport const INSERT_VNODE = 1 << 16;\n/** Indicates a VNode has been matched with another VNode in the diff */\nexport const MATCHED = 1 << 17;\n\n/** Reset all mode flags */\nexport const RESET_MODE = ~(MODE_HYDRATE | MODE_SUSPENDED);\n\nexport const EMPTY_OBJ = /** @type {any} */ ({});\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL =\n\t/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n", "import { EMPTY_ARR } from './constants';\n\nexport const isArray = Array.isArray;\n\n/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\t// @ts-expect-error We change the type of `obj` to be `O & P`\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {preact.ContainerNode} node The node to remove\n */\nexport function removeNode(node) {\n\tlet parentNode = node.parentNode;\n\tif (parentNode) parentNode.removeChild(node);\n}\n\nexport const slice = EMPTY_ARR.slice;\n", "import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n", "import { slice } from './util';\nimport options from './options';\n\nlet vnodeId = 0;\n\n/**\n * Create an virtual node (used for JSX)\n * @param {VNode[\"type\"]} type The node name or Component constructor for this\n * virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the\n * virtual node\n * @returns {VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != null) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] === undefined) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, null);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\t/** @type {VNode} */\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_parent: null,\n\t\t_depth: 0,\n\t\t_dom: null,\n\t\t// _nextDom must be initialized to undefined b/c it will eventually\n\t\t// be set to dom.nextSibling which can return `null` and it is important\n\t\t// to be able to distinguish between an uninitialized _nextDom and\n\t\t// a _nextDom that has been set to `null`\n\t\t_nextDom: undefined,\n\t\t_component: null,\n\t\tconstructor: undefined,\n\t\t_original: original == null ? ++vnodeId : original,\n\t\t_index: -1,\n\t\t_flags: 0\n\t};\n\n\t// Only invoke the vnode hook if this was *not* a direct copy:\n\tif (original == null && options.vnode != null) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn { current: null };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != null && vnode.constructor == undefined;\n", "import { assign } from './util';\nimport { diff, commitRoot } from './diff/index';\nimport options from './options';\nimport { Fragment } from './create-element';\nimport { MODE_HYDRATE } from './constants';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function BaseComponent(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @this {Component}\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nBaseComponent.prototype.setState = function (update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != null && this._nextState !== this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tassign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == null) return;\n\n\tif (this._vnode) {\n\t\tif (callback) {\n\t\t\tthis._stateCallbacks.push(callback);\n\t\t}\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @this {Component}\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nBaseComponent.prototype.forceUpdate = function (callback) {\n\tif (this._vnode) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._force = true;\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {ComponentChildren | void}\n */\nBaseComponent.prototype.render = Fragment;\n\n/**\n * @param {VNode} vnode\n * @param {number | null} [childIndex]\n */\nexport function getDomSibling(vnode, childIndex) {\n\tif (childIndex == null) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn vnode._parent\n\t\t\t? getDomSibling(vnode._parent, vnode._index + 1)\n\t\t\t: null;\n\t}\n\n\tlet sibling;\n\tfor (; childIndex < vnode._children.length; childIndex++) {\n\t\tsibling = vnode._children[childIndex];\n\n\t\tif (sibling != null && sibling._dom != null) {\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\n\t\t\treturn sibling._dom;\n\t\t}\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children.\n\t// We must resume from this vnode's sibling (in it's parent _children array)\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search)\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : null;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {Component} component The component to rerender\n */\nfunction renderComponent(component) {\n\tlet oldVNode = component._vnode,\n\t\toldDom = oldVNode._dom,\n\t\tcommitQueue = [],\n\t\trefQueue = [];\n\n\tif (component._parentDom) {\n\t\tconst newVNode = assign({}, oldVNode);\n\t\tnewVNode._original = oldVNode._original + 1;\n\t\tif (options.vnode) options.vnode(newVNode);\n\n\t\tdiff(\n\t\t\tcomponent._parentDom,\n\t\t\tnewVNode,\n\t\t\toldVNode,\n\t\t\tcomponent._globalContext,\n\t\t\tcomponent._parentDom.namespaceURI,\n\t\t\toldVNode._flags & MODE_HYDRATE ? [oldDom] : null,\n\t\t\tcommitQueue,\n\t\t\toldDom == null ? getDomSibling(oldVNode) : oldDom,\n\t\t\t!!(oldVNode._flags & MODE_HYDRATE),\n\t\t\trefQueue\n\t\t);\n\n\t\tnewVNode._original = oldVNode._original;\n\t\tnewVNode._parent._children[newVNode._index] = newVNode;\n\t\tcommitRoot(commitQueue, newVNode, refQueue);\n\n\t\tif (newVNode._dom != oldDom) {\n\t\t\tupdateParentDomPointers(newVNode);\n\t\t}\n\t}\n}\n\n/**\n * @param {VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n\tif ((vnode = vnode._parent) != null && vnode._component != null) {\n\t\tvnode._dom = vnode._component.base = null;\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child != null && child._dom != null) {\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn updateParentDomPointers(vnode);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<Component>}\n */\nlet rerenderQueue = [];\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\nconst defer =\n\ttypeof Promise == 'function'\n\t\t? Promise.prototype.then.bind(Promise.resolve())\n\t\t: setTimeout;\n\n/**\n * Enqueue a rerender of a component\n * @param {Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!c._dirty &&\n\t\t\t(c._dirty = true) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce !== options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/**\n * @param {Component} a\n * @param {Component} b\n */\nconst depthSort = (a, b) => a._vnode._depth - b._vnode._depth;\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\tlet c;\n\trerenderQueue.sort(depthSort);\n\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t// process() calls from getting scheduled while `queue` is still being consumed.\n\twhile ((c = rerenderQueue.shift())) {\n\t\tif (c._dirty) {\n\t\t\tlet renderQueueLength = rerenderQueue.length;\n\t\t\trenderComponent(c);\n\t\t\tif (rerenderQueue.length > renderQueueLength) {\n\t\t\t\t// When i.e. rerendering a provider additional new items can be injected, we want to\n\t\t\t\t// keep the order from top to bottom with those new items so we can handle them in a\n\t\t\t\t// single pass\n\t\t\t\trerenderQueue.sort(depthSort);\n\t\t\t}\n\t\t}\n\t}\n\tprocess._rerenderCount = 0;\n}\n\nprocess._rerenderCount = 0;\n", "import { IS_NON_DIMENSIONAL } from '../constants';\nimport options from '../options';\n\nfunction setStyle(style, key, value) {\n\tif (key[0] === '-') {\n\t\tstyle.setProperty(key, value == null ? '' : value);\n\t} else if (value == null) {\n\t\tstyle[key] = '';\n\t} else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n\t\tstyle[key] = value;\n\t} else {\n\t\tstyle[key] = value + 'px';\n\t}\n}\n\n// A logical clock to solve issues like https://github.com/preactjs/preact/issues/3927.\n// When the DOM performs an event it leaves micro-ticks in between bubbling up which means that\n// an event can trigger on a newly reated DOM-node while the event bubbles up.\n//\n// Originally inspired by Vue\n// (https://github.com/vuejs/core/blob/caeb8a68811a1b0f79/packages/runtime-dom/src/modules/events.ts#L90-L101),\n// but modified to use a logical clock instead of Date.now() in case event handlers get attached\n// and events get dispatched during the same millisecond.\n//\n// The clock is incremented after each new event dispatch. This allows 1 000 000 new events\n// per second for over 280 years before the value reaches Number.MAX_SAFE_INTEGER (2**53 - 1).\nlet eventClock = 0;\n\n/**\n * Set a property value on a DOM node\n * @param {PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {string} namespace Whether or not this DOM node is an SVG node or not\n */\nexport function setProperty(dom, name, value, oldValue, namespace) {\n\tlet useCapture;\n\n\to: if (name === 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tdom.style.cssText = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tdom.style.cssText = oldValue = '';\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!(value && name in value)) {\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (name in value) {\n\t\t\t\t\tif (!oldValue || value[name] !== oldValue[name]) {\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] === 'o' && name[1] === 'n') {\n\t\tuseCapture =\n\t\t\tname !== (name = name.replace(/(PointerCapture)$|Capture$/i, '$1'));\n\n\t\t// Infer correct casing for DOM built-in events:\n\t\tif (\n\t\t\tname.toLowerCase() in dom ||\n\t\t\tname === 'onFocusOut' ||\n\t\t\tname === 'onFocusIn'\n\t\t)\n\t\t\tname = name.toLowerCase().slice(2);\n\t\telse name = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name + useCapture] = value;\n\n\t\tif (value) {\n\t\t\tif (!oldValue) {\n\t\t\t\tvalue._attached = eventClock;\n\t\t\t\tdom.addEventListener(\n\t\t\t\t\tname,\n\t\t\t\t\tuseCapture ? eventProxyCapture : eventProxy,\n\t\t\t\t\tuseCapture\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tvalue._attached = oldValue._attached;\n\t\t\t}\n\t\t} else {\n\t\t\tdom.removeEventListener(\n\t\t\t\tname,\n\t\t\t\tuseCapture ? eventProxyCapture : eventProxy,\n\t\t\t\tuseCapture\n\t\t\t);\n\t\t}\n\t} else {\n\t\tif (namespace == 'http://www.w3.org/2000/svg') {\n\t\t\t// Normalize incorrect prop usage for SVG:\n\t\t\t// - xlink:href / xlinkHref --> href (xlink:href was removed from SVG and isn't needed)\n\t\t\t// - className --> class\n\t\t\tname = name.replace(/xlink(H|:h)/, 'h').replace(/sName$/, 's');\n\t\t} else if (\n\t\t\tname != 'width' &&\n\t\t\tname != 'height' &&\n\t\t\tname != 'href' &&\n\t\t\tname != 'list' &&\n\t\t\tname != 'form' &&\n\t\t\t// Default value in browsers is `-1` and an empty string is\n\t\t\t// cast to `0` instead\n\t\t\tname != 'tabIndex' &&\n\t\t\tname != 'download' &&\n\t\t\tname != 'rowSpan' &&\n\t\t\tname != 'colSpan' &&\n\t\t\tname != 'role' &&\n\t\t\tname != 'popover' &&\n\t\t\tname in dom\n\t\t) {\n\t\t\ttry {\n\t\t\t\tdom[name] = value == null ? '' : value;\n\t\t\t\t// labelled break is 1b smaller here than a return statement (sorry)\n\t\t\t\tbreak o;\n\t\t\t} catch (e) {}\n\t\t}\n\n\t\t// aria- and data- attributes have no boolean representation.\n\t\t// A `false` value is different from the attribute not being\n\t\t// present, so we can't remove it. For non-boolean aria\n\t\t// attributes we could treat false as a removal, but the\n\t\t// amount of exceptions would cost too many bytes. On top of\n\t\t// that other frameworks generally stringify `false`.\n\n\t\tif (typeof value == 'function') {\n\t\t\t// never serialize functions as attribute values\n\t\t} else if (value != null && (value !== false || name[4] === '-')) {\n\t\t\tdom.setAttribute(name, name == 'popover' && value == true ? '' : value);\n\t\t} else {\n\t\t\tdom.removeAttribute(name);\n\t\t}\n\t}\n}\n\n/**\n * Create an event proxy function.\n * @param {boolean} useCapture Is the event handler for the capture phase.\n * @private\n */\nfunction createEventProxy(useCapture) {\n\t/**\n\t * Proxy an event to hooked event handlers\n\t * @param {PreactEvent} e The event object from the browser\n\t * @private\n\t */\n\treturn function (e) {\n\t\tif (this._listeners) {\n\t\t\tconst eventHandler = this._listeners[e.type + useCapture];\n\t\t\tif (e._dispatched == null) {\n\t\t\t\te._dispatched = eventClock++;\n\n\t\t\t\t// When `e._dispatched` is smaller than the time when the targeted event\n\t\t\t\t// handler was attached we know we have bubbled up to an element that was added\n\t\t\t\t// during patching the DOM.\n\t\t\t} else if (e._dispatched < eventHandler._attached) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn eventHandler(options.event ? options.event(e) : e);\n\t\t}\n\t};\n}\n\nconst eventProxy = createEventProxy(false);\nconst eventProxyCapture = createEventProxy(true);\n", "import { enqueueRender } from './component';\n\nexport let i = 0;\n\nexport function createContext(defaultValue, contextId) {\n\tcontextId = '__cC' + i++;\n\n\tconst context = {\n\t\t_id: contextId,\n\t\t_defaultValue: defaultValue,\n\t\t/** @type {FunctionComponent} */\n\t\tConsumer(props, contextValue) {\n\t\t\t// return props.children(\n\t\t\t// \tcontext[contextId] ? context[contextId].props.value : defaultValue\n\t\t\t// );\n\t\t\treturn props.children(contextValue);\n\t\t},\n\t\t/** @type {FunctionComponent} */\n\t\tProvider(props) {\n\t\t\tif (!this.getChildContext) {\n\t\t\t\t/** @type {Component[] | null} */\n\t\t\t\tlet subs = [];\n\t\t\t\tlet ctx = {};\n\t\t\t\tctx[contextId] = this;\n\n\t\t\t\tthis.getChildContext = () => ctx;\n\n\t\t\t\tthis.componentWillUnmount = () => {\n\t\t\t\t\tsubs = null;\n\t\t\t\t};\n\n\t\t\t\tthis.shouldComponentUpdate = function (_props) {\n\t\t\t\t\tif (this.props.value !== _props.value) {\n\t\t\t\t\t\tsubs.some(c => {\n\t\t\t\t\t\t\tc._force = true;\n\t\t\t\t\t\t\tenqueueRender(c);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.sub = c => {\n\t\t\t\t\tsubs.push(c);\n\t\t\t\t\tlet old = c.componentWillUnmount;\n\t\t\t\t\tc.componentWillUnmount = () => {\n\t\t\t\t\t\tif (subs) {\n\t\t\t\t\t\t\tsubs.splice(subs.indexOf(c), 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (old) old.call(c);\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn props.children;\n\t\t}\n\t};\n\n\t// Devtools needs access to the context object when it\n\t// encounters a Provider. This is necessary to support\n\t// setting `displayName` on the context object instead\n\t// of on the component itself. See:\n\t// https://reactjs.org/docs/context.html#contextdisplayname\n\n\treturn (context.Provider._contextRef = context.Consumer.contextType =\n\t\tcontext);\n}\n", "import { diff, unmount, applyRef } from './index';\nimport { createVNode, Fragment } from '../create-element';\nimport { EMPTY_OBJ, EMPTY_ARR, INSERT_VNODE, MATCHED } from '../constants';\nimport { isArray } from '../util';\nimport { getDomSibling } from '../component';\n\n/**\n * Diff the children of a virtual node\n * @param {PreactElement} parentDom The DOM element whose children are being\n * diffed\n * @param {ComponentChildren[]} renderResult\n * @param {VNode} newParentVNode The new virtual node whose children should be\n * diff'ed against oldParentVNode\n * @param {VNode} oldParentVNode The old virtual node whose children should be\n * diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tnewParentVNode,\n\toldParentVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating,\n\trefQueue\n) {\n\tlet i,\n\t\t/** @type {VNode} */\n\t\toldVNode,\n\t\t/** @type {VNode} */\n\t\tchildVNode,\n\t\t/** @type {PreactElement} */\n\t\tnewDom,\n\t\t/** @type {PreactElement} */\n\t\tfirstChildDom;\n\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n\t// as EMPTY_OBJ._children should be `undefined`.\n\t/** @type {VNode[]} */\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\n\n\tlet newChildrenLength = renderResult.length;\n\n\tnewParentVNode._nextDom = oldDom;\n\tconstructNewChildrenArray(newParentVNode, renderResult, oldChildren);\n\toldDom = newParentVNode._nextDom;\n\n\tfor (i = 0; i < newChildrenLength; i++) {\n\t\tchildVNode = newParentVNode._children[i];\n\t\tif (\n\t\t\tchildVNode == null ||\n\t\t\ttypeof childVNode == 'boolean' ||\n\t\t\ttypeof childVNode == 'function'\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// At this point, constructNewChildrenArray has assigned _index to be the\n\t\t// matchingIndex for this VNode's oldVNode (or -1 if there is no oldVNode).\n\t\tif (childVNode._index === -1) {\n\t\t\toldVNode = EMPTY_OBJ;\n\t\t} else {\n\t\t\toldVNode = oldChildren[childVNode._index] || EMPTY_OBJ;\n\t\t}\n\n\t\t// Update childVNode._index to its final index\n\t\tchildVNode._index = i;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tdiff(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tnamespace,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\toldDom,\n\t\t\tisHydrating,\n\t\t\trefQueue\n\t\t);\n\n\t\t// Adjust DOM nodes\n\t\tnewDom = childVNode._dom;\n\t\tif (childVNode.ref && oldVNode.ref != childVNode.ref) {\n\t\t\tif (oldVNode.ref) {\n\t\t\t\tapplyRef(oldVNode.ref, null, childVNode);\n\t\t\t}\n\t\t\trefQueue.push(\n\t\t\t\tchildVNode.ref,\n\t\t\t\tchildVNode._component || newDom,\n\t\t\t\tchildVNode\n\t\t\t);\n\t\t}\n\n\t\tif (firstChildDom == null && newDom != null) {\n\t\t\tfirstChildDom = newDom;\n\t\t}\n\n\t\tif (\n\t\t\tchildVNode._flags & INSERT_VNODE ||\n\t\t\toldVNode._children === childVNode._children\n\t\t) {\n\t\t\tif (\n\t\t\t\toldDom &&\n\t\t\t\ttypeof childVNode.type == 'string' &&\n\t\t\t\t// @ts-expect-error olDom should be present on a DOM node\n\t\t\t\t!parentDom.contains(oldDom)\n\t\t\t) {\n\t\t\t\toldDom = getDomSibling(oldVNode);\n\t\t\t}\n\t\t\toldDom = insert(childVNode, oldDom, parentDom);\n\t\t} else if (\n\t\t\ttypeof childVNode.type == 'function' &&\n\t\t\tchildVNode._nextDom !== undefined\n\t\t) {\n\t\t\t// Since Fragments or components that return Fragment like VNodes can\n\t\t\t// contain multiple DOM nodes as the same level, continue the diff from\n\t\t\t// the sibling of last DOM child of this child VNode\n\t\t\toldDom = childVNode._nextDom;\n\t\t} else if (newDom) {\n\t\t\toldDom = newDom.nextSibling;\n\t\t}\n\n\t\t// Eagerly cleanup _nextDom. We don't need to persist the value because it\n\t\t// is only used by `diffChildren` to determine where to resume the diff\n\t\t// after diffing Components and Fragments. Once we store it the nextDOM\n\t\t// local var, we can clean up the property. Also prevents us hanging on to\n\t\t// DOM nodes that may have been unmounted.\n\t\tchildVNode._nextDom = undefined;\n\n\t\t// Unset diffing flags\n\t\tchildVNode._flags &= ~(INSERT_VNODE | MATCHED);\n\t}\n\n\t// TODO: With new child diffing algo, consider alt ways to diff Fragments.\n\t// Such as dropping oldDom and moving fragments in place\n\t//\n\t// Because the newParentVNode is Fragment-like, we need to set it's\n\t// _nextDom property to the nextSibling of its last child DOM node.\n\t//\n\t// `oldDom` contains the correct value here because if the last child\n\t// is a Fragment-like, then oldDom has already been set to that child's _nextDom.\n\t// If the last child is a DOM VNode, then oldDom will be set to that DOM\n\t// node's nextSibling.\n\tnewParentVNode._nextDom = oldDom;\n\tnewParentVNode._dom = firstChildDom;\n}\n\n/**\n * @param {VNode} newParentVNode\n * @param {ComponentChildren[]} renderResult\n * @param {VNode[]} oldChildren\n */\nfunction constructNewChildrenArray(newParentVNode, renderResult, oldChildren) {\n\t/** @type {number} */\n\tlet i;\n\t/** @type {VNode} */\n\tlet childVNode;\n\t/** @type {VNode} */\n\tlet oldVNode;\n\n\tconst newChildrenLength = renderResult.length;\n\tlet oldChildrenLength = oldChildren.length,\n\t\tremainingOldChildren = oldChildrenLength;\n\n\tlet skew = 0;\n\n\tnewParentVNode._children = [];\n\tfor (i = 0; i < newChildrenLength; i++) {\n\t\t// @ts-expect-error We are reusing the childVNode variable to hold both the\n\t\t// pre and post normalized childVNode\n\t\tchildVNode = renderResult[i];\n\n\t\tif (\n\t\t\tchildVNode == null ||\n\t\t\ttypeof childVNode == 'boolean' ||\n\t\t\ttypeof childVNode == 'function'\n\t\t) {\n\t\t\tchildVNode = newParentVNode._children[i] = null;\n\t\t}\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t\t// it's own DOM & etc. pointers\n\t\telse if (\n\t\t\ttypeof childVNode == 'string' ||\n\t\t\ttypeof childVNode == 'number' ||\n\t\t\t// eslint-disable-next-line valid-typeof\n\t\t\ttypeof childVNode == 'bigint' ||\n\t\t\tchildVNode.constructor == String\n\t\t) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tnull,\n\t\t\t\tchildVNode,\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if (isArray(childVNode)) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tFragment,\n\t\t\t\t{ children: childVNode },\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if (childVNode.constructor === undefined && childVNode._depth > 0) {\n\t\t\t// VNode is already in use, clone it. This can happen in the following\n\t\t\t// scenario:\n\t\t\t//   const reuse = <div />\n\t\t\t//   <div>{reuse}<span />{reuse}</div>\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tchildVNode.type,\n\t\t\t\tchildVNode.props,\n\t\t\t\tchildVNode.key,\n\t\t\t\tchildVNode.ref ? childVNode.ref : null,\n\t\t\t\tchildVNode._original\n\t\t\t);\n\t\t} else {\n\t\t\tchildVNode = newParentVNode._children[i] = childVNode;\n\t\t}\n\n\t\tconst skewedIndex = i + skew;\n\n\t\t// Handle unmounting null placeholders, i.e. VNode => null in unkeyed children\n\t\tif (childVNode == null) {\n\t\t\toldVNode = oldChildren[skewedIndex];\n\t\t\tif (\n\t\t\t\toldVNode &&\n\t\t\t\toldVNode.key == null &&\n\t\t\t\toldVNode._dom &&\n\t\t\t\t(oldVNode._flags & MATCHED) === 0\n\t\t\t) {\n\t\t\t\tif (oldVNode._dom == newParentVNode._nextDom) {\n\t\t\t\t\tnewParentVNode._nextDom = getDomSibling(oldVNode);\n\t\t\t\t}\n\n\t\t\t\tunmount(oldVNode, oldVNode, false);\n\n\t\t\t\t// Explicitly nullify this position in oldChildren instead of just\n\t\t\t\t// setting `_match=true` to prevent other routines (e.g.\n\t\t\t\t// `findMatchingIndex` or `getDomSibling`) from thinking VNodes or DOM\n\t\t\t\t// nodes in this position are still available to be used in diffing when\n\t\t\t\t// they have actually already been unmounted. For example, by only\n\t\t\t\t// setting `_match=true` here, the unmounting loop later would attempt\n\t\t\t\t// to unmount this VNode again seeing `_match==true`.  Further,\n\t\t\t\t// getDomSibling doesn't know about _match and so would incorrectly\n\t\t\t\t// assume DOM nodes in this subtree are mounted and usable.\n\t\t\t\toldChildren[skewedIndex] = null;\n\t\t\t\tremainingOldChildren--;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tchildVNode._parent = newParentVNode;\n\t\tchildVNode._depth = newParentVNode._depth + 1;\n\n\t\tconst matchingIndex = findMatchingIndex(\n\t\t\tchildVNode,\n\t\t\toldChildren,\n\t\t\tskewedIndex,\n\t\t\tremainingOldChildren\n\t\t);\n\n\t\t// Temporarily store the matchingIndex on the _index property so we can pull\n\t\t// out the oldVNode in diffChildren. We'll override this to the VNode's\n\t\t// final index after using this property to get the oldVNode\n\t\tchildVNode._index = matchingIndex;\n\n\t\toldVNode = null;\n\t\tif (matchingIndex !== -1) {\n\t\t\toldVNode = oldChildren[matchingIndex];\n\t\t\tremainingOldChildren--;\n\t\t\tif (oldVNode) {\n\t\t\t\toldVNode._flags |= MATCHED;\n\t\t\t}\n\t\t}\n\n\t\t// Here, we define isMounting for the purposes of the skew diffing\n\t\t// algorithm. Nodes that are unsuspending are considered mounting and we detect\n\t\t// this by checking if oldVNode._original === null\n\t\tconst isMounting = oldVNode == null || oldVNode._original === null;\n\n\t\tif (isMounting) {\n\t\t\tif (matchingIndex == -1) {\n\t\t\t\tskew--;\n\t\t\t}\n\n\t\t\t// If we are mounting a DOM VNode, mark it for insertion\n\t\t\tif (typeof childVNode.type != 'function') {\n\t\t\t\tchildVNode._flags |= INSERT_VNODE;\n\t\t\t}\n\t\t} else if (matchingIndex !== skewedIndex) {\n\t\t\tif (matchingIndex == skewedIndex - 1) {\n\t\t\t\tskew = matchingIndex - skewedIndex;\n\t\t\t} else if (matchingIndex == skewedIndex + 1) {\n\t\t\t\tskew++;\n\t\t\t} else if (matchingIndex > skewedIndex) {\n\t\t\t\t// Our matched DOM-node is further in the list of children than\n\t\t\t\t// where it's at now.\n\n\t\t\t\t// When the remaining old children is bigger than the new-children\n\t\t\t\t// minus our skewed index we know we are dealing with a shrinking list\n\t\t\t\t// we have to increase our skew with the matchedIndex - the skewed index\n\t\t\t\tif (remainingOldChildren > newChildrenLength - skewedIndex) {\n\t\t\t\t\tskew += matchingIndex - skewedIndex;\n\t\t\t\t} else {\n\t\t\t\t\t// If we have matched all the children just decrease the skew\n\t\t\t\t\tskew--;\n\t\t\t\t}\n\t\t\t} else if (matchingIndex < skewedIndex) {\n\t\t\t\t// When our new position is in front of our old position than we increase the skew\n\t\t\t\tskew++;\n\t\t\t}\n\n\t\t\t// Move this VNode's DOM if the original index (matchingIndex) doesn't\n\t\t\t// match the new skew index (i + new skew)\n\t\t\tif (matchingIndex !== i + skew) {\n\t\t\t\tchildVNode._flags |= INSERT_VNODE;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove remaining oldChildren if there are any. Loop forwards so that as we\n\t// unmount DOM from the beginning of the oldChildren, we can adjust oldDom to\n\t// point to the next child, which needs to be the first DOM node that won't be\n\t// unmounted.\n\tif (remainingOldChildren) {\n\t\tfor (i = 0; i < oldChildrenLength; i++) {\n\t\t\toldVNode = oldChildren[i];\n\t\t\tif (oldVNode != null && (oldVNode._flags & MATCHED) === 0) {\n\t\t\t\tif (oldVNode._dom == newParentVNode._nextDom) {\n\t\t\t\t\tnewParentVNode._nextDom = getDomSibling(oldVNode);\n\t\t\t\t}\n\n\t\t\t\tunmount(oldVNode, oldVNode);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @param {VNode} parentVNode\n * @param {PreactElement} oldDom\n * @param {PreactElement} parentDom\n * @returns {PreactElement}\n */\nfunction insert(parentVNode, oldDom, parentDom) {\n\t// Note: VNodes in nested suspended trees may be missing _children.\n\n\tif (typeof parentVNode.type == 'function') {\n\t\tlet children = parentVNode._children;\n\t\tfor (let i = 0; children && i < children.length; i++) {\n\t\t\tif (children[i]) {\n\t\t\t\t// If we enter this code path on sCU bailout, where we copy\n\t\t\t\t// oldVNode._children to newVNode._children, we need to update the old\n\t\t\t\t// children's _parent pointer to point to the newVNode (parentVNode\n\t\t\t\t// here).\n\t\t\t\tchildren[i]._parent = parentVNode;\n\t\t\t\toldDom = insert(children[i], oldDom, parentDom);\n\t\t\t}\n\t\t}\n\n\t\treturn oldDom;\n\t} else if (parentVNode._dom != oldDom) {\n\t\tparentDom.insertBefore(parentVNode._dom, oldDom || null);\n\t\toldDom = parentVNode._dom;\n\t}\n\n\tdo {\n\t\toldDom = oldDom && oldDom.nextSibling;\n\t} while (oldDom != null && oldDom.nodeType === 8);\n\n\treturn oldDom;\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {ComponentChildren} children The unflattened children of a virtual\n * node\n * @returns {VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == null || typeof children == 'boolean') {\n\t} else if (isArray(children)) {\n\t\tchildren.some(child => {\n\t\t\ttoChildArray(child, out);\n\t\t});\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n\n/**\n * @param {VNode} childVNode\n * @param {VNode[]} oldChildren\n * @param {number} skewedIndex\n * @param {number} remainingOldChildren\n * @returns {number}\n */\nfunction findMatchingIndex(\n\tchildVNode,\n\toldChildren,\n\tskewedIndex,\n\tremainingOldChildren\n) {\n\tconst key = childVNode.key;\n\tconst type = childVNode.type;\n\tlet x = skewedIndex - 1;\n\tlet y = skewedIndex + 1;\n\tlet oldVNode = oldChildren[skewedIndex];\n\n\t// We only need to perform a search if there are more children\n\t// (remainingOldChildren) to search. However, if the oldVNode we just looked\n\t// at skewedIndex was not already used in this diff, then there must be at\n\t// least 1 other (so greater than 1) remainingOldChildren to attempt to match\n\t// against. So the following condition checks that ensuring\n\t// remainingOldChildren > 1 if the oldVNode is not already used/matched. Else\n\t// if the oldVNode was null or matched, then there could needs to be at least\n\t// 1 (aka `remainingOldChildren > 0`) children to find and compare against.\n\tlet shouldSearch =\n\t\tremainingOldChildren >\n\t\t(oldVNode != null && (oldVNode._flags & MATCHED) === 0 ? 1 : 0);\n\n\tif (\n\t\toldVNode === null ||\n\t\t(oldVNode &&\n\t\t\tkey == oldVNode.key &&\n\t\t\ttype === oldVNode.type &&\n\t\t\t(oldVNode._flags & MATCHED) === 0)\n\t) {\n\t\treturn skewedIndex;\n\t} else if (shouldSearch) {\n\t\twhile (x >= 0 || y < oldChildren.length) {\n\t\t\tif (x >= 0) {\n\t\t\t\toldVNode = oldChildren[x];\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\t(oldVNode._flags & MATCHED) === 0 &&\n\t\t\t\t\tkey == oldVNode.key &&\n\t\t\t\t\ttype === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\treturn x;\n\t\t\t\t}\n\t\t\t\tx--;\n\t\t\t}\n\n\t\t\tif (y < oldChildren.length) {\n\t\t\t\toldVNode = oldChildren[y];\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\t(oldVNode._flags & MATCHED) === 0 &&\n\t\t\t\t\tkey == oldVNode.key &&\n\t\t\t\t\ttype === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\treturn y;\n\t\t\t\t}\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n", "import {\n\tEMPTY_OBJ,\n\tMODE_HYDRATE,\n\tMODE_SUSPENDED,\n\tRESET_MODE\n} from '../constants';\nimport { BaseComponent, getDomSibling } from '../component';\nimport { Fragment } from '../create-element';\nimport { diffChildren } from './children';\nimport { setProperty } from './props';\nimport { assign, isArray, removeNode, slice } from '../util';\nimport options from '../options';\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {PreactElement} parentDom The parent of the DOM element\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nexport function diff(\n\tparentDom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating,\n\trefQueue\n) {\n\t/** @type {any} */\n\tlet tmp,\n\t\tnewType = newVNode.type;\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor !== undefined) return null;\n\n\t// If the previous diff bailed out, resume creating/hydrating.\n\tif (oldVNode._flags & MODE_SUSPENDED) {\n\t\tisHydrating = !!(oldVNode._flags & MODE_HYDRATE);\n\t\toldDom = newVNode._dom = oldVNode._dom;\n\t\texcessDomChildren = [oldDom];\n\t}\n\n\tif ((tmp = options._diff)) tmp(newVNode);\n\n\touter: if (typeof newType == 'function') {\n\t\ttry {\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n\t\t\tlet newProps = newVNode.props;\n\t\t\tconst isClassComponent =\n\t\t\t\t'prototype' in newType && newType.prototype.render;\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\ttmp = newType.contextType;\n\t\t\tlet provider = tmp && globalContext[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: globalContext;\n\n\t\t\t// Get component and set it to `c`\n\t\t\tif (oldVNode._component) {\n\t\t\t\tc = newVNode._component = oldVNode._component;\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\n\t\t\t} else {\n\t\t\t\t// Instantiate the new component\n\t\t\t\tif (isClassComponent) {\n\t\t\t\t\t// @ts-expect-error The check above verifies that newType is suppose to be constructed\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-expect-error Trust me, Component implements the interface we want\n\t\t\t\t\tnewVNode._component = c = new BaseComponent(\n\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t);\n\t\t\t\t\tc.constructor = newType;\n\t\t\t\t\tc.render = doRender;\n\t\t\t\t}\n\t\t\t\tif (provider) provider.sub(c);\n\n\t\t\t\tc.props = newProps;\n\t\t\t\tif (!c.state) c.state = {};\n\t\t\t\tc.context = componentContext;\n\t\t\t\tc._globalContext = globalContext;\n\t\t\t\tisNew = c._dirty = true;\n\t\t\t\tc._renderCallbacks = [];\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t}\n\n\t\t\t// Invoke getDerivedStateFromProps\n\t\t\tif (isClassComponent && c._nextState == null) {\n\t\t\t\tc._nextState = c.state;\n\t\t\t}\n\n\t\t\tif (isClassComponent && newType.getDerivedStateFromProps != null) {\n\t\t\t\tif (c._nextState == c.state) {\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\n\t\t\t\t}\n\n\t\t\t\tassign(\n\t\t\t\t\tc._nextState,\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\toldProps = c.props;\n\t\t\toldState = c.state;\n\t\t\tc._vnode = newVNode;\n\n\t\t\t// Invoke pre-render lifecycle methods\n\t\t\tif (isNew) {\n\t\t\t\tif (\n\t\t\t\t\tisClassComponent &&\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tc.componentWillMount != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillMount();\n\t\t\t\t}\n\n\t\t\t\tif (isClassComponent && c.componentDidMount != null) {\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tisClassComponent &&\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tnewProps !== oldProps &&\n\t\t\t\t\tc.componentWillReceiveProps != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t!c._force &&\n\t\t\t\t\t((c.shouldComponentUpdate != null &&\n\t\t\t\t\t\tc.shouldComponentUpdate(\n\t\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\t\tc._nextState,\n\t\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t\t) === false) ||\n\t\t\t\t\t\tnewVNode._original === oldVNode._original)\n\t\t\t\t) {\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\t\tif (newVNode._original !== oldVNode._original) {\n\t\t\t\t\t\t// When we are dealing with a bail because of sCU we have to update\n\t\t\t\t\t\t// the props, state and dirty-state.\n\t\t\t\t\t\t// when we are dealing with strict-equality we don't as the child could still\n\t\t\t\t\t\t// be dirtied see #3883\n\t\t\t\t\t\tc.props = newProps;\n\t\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t\t\tc._dirty = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t\tnewVNode._children.forEach(vnode => {\n\t\t\t\t\t\tif (vnode) vnode._parent = newVNode;\n\t\t\t\t\t});\n\n\t\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t\t}\n\t\t\t\t\tc._stateCallbacks = [];\n\n\t\t\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\t\t\tcommitQueue.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t\tif (c.componentWillUpdate != null) {\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (isClassComponent && c.componentDidUpdate != null) {\n\t\t\t\t\tc._renderCallbacks.push(() => {\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.context = componentContext;\n\t\t\tc.props = newProps;\n\t\t\tc._parentDom = parentDom;\n\t\t\tc._force = false;\n\n\t\t\tlet renderHook = options._render,\n\t\t\t\tcount = 0;\n\t\t\tif (isClassComponent) {\n\t\t\t\tc.state = c._nextState;\n\t\t\t\tc._dirty = false;\n\n\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t}\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tc._dirty = false;\n\t\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\t\t// Handle setState called in render, see #2553\n\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t} while (c._dirty && ++count < 25);\n\t\t\t}\n\n\t\t\t// Handle setState called in render, see #2553\n\t\t\tc.state = c._nextState;\n\n\t\t\tif (c.getChildContext != null) {\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\n\t\t\t}\n\n\t\t\tif (isClassComponent && !isNew && c.getSnapshotBeforeUpdate != null) {\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\ttmp != null && tmp.type === Fragment && tmp.key == null;\n\t\t\tlet renderResult = isTopLevelFragment ? tmp.props.children : tmp;\n\n\t\t\tdiffChildren(\n\t\t\t\tparentDom,\n\t\t\t\tisArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnamespace,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\toldDom,\n\t\t\t\tisHydrating,\n\t\t\t\trefQueue\n\t\t\t);\n\n\t\t\tc.base = newVNode._dom;\n\n\t\t\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\t\t\tnewVNode._flags &= RESET_MODE;\n\n\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\tcommitQueue.push(c);\n\t\t\t}\n\n\t\t\tif (clearProcessingException) {\n\t\t\t\tc._pendingError = c._processingException = null;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tnewVNode._original = null;\n\t\t\t// if hydrating or creating initial tree, bailout preserves DOM:\n\t\t\tif (isHydrating || excessDomChildren != null) {\n\t\t\t\tnewVNode._dom = oldDom;\n\t\t\t\tnewVNode._flags |= isHydrating\n\t\t\t\t\t? MODE_HYDRATE | MODE_SUSPENDED\n\t\t\t\t\t: MODE_HYDRATE;\n\t\t\t\texcessDomChildren[excessDomChildren.indexOf(oldDom)] = null;\n\t\t\t\t// ^ could possibly be simplified to:\n\t\t\t\t// excessDomChildren.length = 0;\n\t\t\t} else {\n\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t}\n\t\t\toptions._catchError(e, newVNode, oldVNode);\n\t\t}\n\t} else if (\n\t\texcessDomChildren == null &&\n\t\tnewVNode._original === oldVNode._original\n\t) {\n\t\tnewVNode._children = oldVNode._children;\n\t\tnewVNode._dom = oldVNode._dom;\n\t} else {\n\t\tnewVNode._dom = diffElementNodes(\n\t\t\toldVNode._dom,\n\t\t\tnewVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tnamespace,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\tisHydrating,\n\t\t\trefQueue\n\t\t);\n\t}\n\n\tif ((tmp = options.diffed)) tmp(newVNode);\n}\n\n/**\n * @param {Array<Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {VNode} root\n */\nexport function commitRoot(commitQueue, root, refQueue) {\n\troot._nextDom = undefined;\n\n\tfor (let i = 0; i < refQueue.length; i++) {\n\t\tapplyRef(refQueue[i], refQueue[++i], refQueue[++i]);\n\t}\n\n\tif (options._commit) options._commit(root, commitQueue);\n\n\tcommitQueue.some(c => {\n\t\ttry {\n\t\t\t// @ts-expect-error Reuse the commitQueue variable here so the type changes\n\t\t\tcommitQueue = c._renderCallbacks;\n\t\t\tc._renderCallbacks = [];\n\t\t\tcommitQueue.some(cb => {\n\t\t\t\t// @ts-expect-error See above comment on commitQueue\n\t\t\t\tcb.call(c);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t});\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {PreactElement} dom The DOM element representing the virtual nodes\n * being diffed\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n * @returns {PreactElement}\n */\nfunction diffElementNodes(\n\tdom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\tisHydrating,\n\trefQueue\n) {\n\tlet oldProps = oldVNode.props;\n\tlet newProps = newVNode.props;\n\tlet nodeType = /** @type {string} */ (newVNode.type);\n\t/** @type {any} */\n\tlet i;\n\t/** @type {{ __html?: string }} */\n\tlet newHtml;\n\t/** @type {{ __html?: string }} */\n\tlet oldHtml;\n\t/** @type {ComponentChildren} */\n\tlet newChildren;\n\tlet value;\n\tlet inputValue;\n\tlet checked;\n\n\t// Tracks entering and exiting namespaces when descending through the tree.\n\tif (nodeType === 'svg') namespace = 'http://www.w3.org/2000/svg';\n\telse if (nodeType === 'math')\n\t\tnamespace = 'http://www.w3.org/1998/Math/MathML';\n\telse if (!namespace) namespace = 'http://www.w3.org/1999/xhtml';\n\n\tif (excessDomChildren != null) {\n\t\tfor (i = 0; i < excessDomChildren.length; i++) {\n\t\t\tvalue = excessDomChildren[i];\n\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\n\t\t\t// argument matches an element in excessDomChildren, remove it from\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\n\t\t\tif (\n\t\t\t\tvalue &&\n\t\t\t\t'setAttribute' in value === !!nodeType &&\n\t\t\t\t(nodeType ? value.localName === nodeType : value.nodeType === 3)\n\t\t\t) {\n\t\t\t\tdom = value;\n\t\t\t\texcessDomChildren[i] = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom == null) {\n\t\tif (nodeType === null) {\n\t\t\treturn document.createTextNode(newProps);\n\t\t}\n\n\t\tdom = document.createElementNS(\n\t\t\tnamespace,\n\t\t\tnodeType,\n\t\t\tnewProps.is && newProps\n\t\t);\n\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = null;\n\t\t// we are creating a new node, so we can assume this is a new subtree (in\n\t\t// case we are hydrating), this deopts the hydrate\n\t\tisHydrating = false;\n\t}\n\n\tif (nodeType === null) {\n\t\t// During hydration, we still have to split merged text from SSR'd HTML.\n\t\tif (oldProps !== newProps && (!isHydrating || dom.data !== newProps)) {\n\t\t\tdom.data = newProps;\n\t\t}\n\t} else {\n\t\t// If excessDomChildren was not null, repopulate it with the current element's children:\n\t\texcessDomChildren = excessDomChildren && slice.call(dom.childNodes);\n\n\t\toldProps = oldVNode.props || EMPTY_OBJ;\n\n\t\t// If we are in a situation where we are not hydrating but are using\n\t\t// existing DOM (e.g. replaceNode) we should read the existing DOM\n\t\t// attributes to diff them\n\t\tif (!isHydrating && excessDomChildren != null) {\n\t\t\toldProps = {};\n\t\t\tfor (i = 0; i < dom.attributes.length; i++) {\n\t\t\t\tvalue = dom.attributes[i];\n\t\t\t\toldProps[value.name] = value.value;\n\t\t\t}\n\t\t}\n\n\t\tfor (i in oldProps) {\n\t\t\tvalue = oldProps[i];\n\t\t\tif (i == 'children') {\n\t\t\t} else if (i == 'dangerouslySetInnerHTML') {\n\t\t\t\toldHtml = value;\n\t\t\t} else if (i !== 'key' && !(i in newProps)) {\n\t\t\t\tif (\n\t\t\t\t\t(i == 'value' && 'defaultValue' in newProps) ||\n\t\t\t\t\t(i == 'checked' && 'defaultChecked' in newProps)\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsetProperty(dom, i, null, value, namespace);\n\t\t\t}\n\t\t}\n\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n\t\t// @TODO we should warn in debug mode when props don't match here.\n\t\tfor (i in newProps) {\n\t\t\tvalue = newProps[i];\n\t\t\tif (i == 'children') {\n\t\t\t\tnewChildren = value;\n\t\t\t} else if (i == 'dangerouslySetInnerHTML') {\n\t\t\t\tnewHtml = value;\n\t\t\t} else if (i == 'value') {\n\t\t\t\tinputValue = value;\n\t\t\t} else if (i == 'checked') {\n\t\t\t\tchecked = value;\n\t\t\t} else if (\n\t\t\t\ti !== 'key' &&\n\t\t\t\t(!isHydrating || typeof value == 'function') &&\n\t\t\t\toldProps[i] !== value\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, value, oldProps[i], namespace);\n\t\t\t}\n\t\t}\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\tif (\n\t\t\t\t!isHydrating &&\n\t\t\t\t(!oldHtml ||\n\t\t\t\t\t(newHtml.__html !== oldHtml.__html &&\n\t\t\t\t\t\tnewHtml.__html !== dom.innerHTML))\n\t\t\t) {\n\t\t\t\tdom.innerHTML = newHtml.__html;\n\t\t\t}\n\n\t\t\tnewVNode._children = [];\n\t\t} else {\n\t\t\tif (oldHtml) dom.innerHTML = '';\n\n\t\t\tdiffChildren(\n\t\t\t\tdom,\n\t\t\t\tisArray(newChildren) ? newChildren : [newChildren],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnodeType === 'foreignObject'\n\t\t\t\t\t? 'http://www.w3.org/1999/xhtml'\n\t\t\t\t\t: namespace,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\texcessDomChildren\n\t\t\t\t\t? excessDomChildren[0]\n\t\t\t\t\t: oldVNode._children && getDomSibling(oldVNode, 0),\n\t\t\t\tisHydrating,\n\t\t\t\trefQueue\n\t\t\t);\n\n\t\t\t// Remove children that are not part of any vnode.\n\t\t\tif (excessDomChildren != null) {\n\t\t\t\tfor (i = excessDomChildren.length; i--; ) {\n\t\t\t\t\tif (excessDomChildren[i] != null) removeNode(excessDomChildren[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// As above, don't diff props during hydration\n\t\tif (!isHydrating) {\n\t\t\ti = 'value';\n\t\t\tif (\n\t\t\t\tinputValue !== undefined &&\n\t\t\t\t// #2756 For the <progress>-element the initial value is 0,\n\t\t\t\t// despite the attribute not being present. When the attribute\n\t\t\t\t// is missing the progress bar is treated as indeterminate.\n\t\t\t\t// To fix that we'll always update it when it is 0 for progress elements\n\t\t\t\t(inputValue !== dom[i] ||\n\t\t\t\t\t(nodeType === 'progress' && !inputValue) ||\n\t\t\t\t\t// This is only for IE 11 to fix <select> value not being updated.\n\t\t\t\t\t// To avoid a stale select value we need to set the option.value\n\t\t\t\t\t// again, which triggers IE11 to re-evaluate the select value\n\t\t\t\t\t(nodeType === 'option' && inputValue !== oldProps[i]))\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, inputValue, oldProps[i], namespace);\n\t\t\t}\n\n\t\t\ti = 'checked';\n\t\t\tif (checked !== undefined && checked !== dom[i]) {\n\t\t\t\tsetProperty(dom, i, checked, oldProps[i], namespace);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {Ref<any>} ref\n * @param {any} value\n * @param {VNode} vnode\n */\nexport function applyRef(ref, value, vnode) {\n\ttry {\n\t\tif (typeof ref == 'function') ref(value);\n\t\telse ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, vnode);\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {VNode} vnode The virtual node to unmount\n * @param {VNode} parentVNode The parent of the VNode that initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, parentVNode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif ((r = vnode.ref)) {\n\t\tif (!r.current || r.current === vnode._dom) {\n\t\t\tapplyRef(r, null, parentVNode);\n\t\t}\n\t}\n\n\tif ((r = vnode._component) != null) {\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentVNode);\n\t\t\t}\n\t\t}\n\n\t\tr.base = r._parentDom = null;\n\t}\n\n\tif ((r = vnode._children)) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tif (r[i]) {\n\t\t\t\tunmount(\n\t\t\t\t\tr[i],\n\t\t\t\t\tparentVNode,\n\t\t\t\t\tskipRemove || typeof vnode.type != 'function'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!skipRemove && vnode._dom != null) {\n\t\tremoveNode(vnode._dom);\n\t}\n\n\t// Must be set to `undefined` to properly clean up `_nextDom`\n\t// for which `null` is a valid value. See comment in `create-element.js`\n\tvnode._component = vnode._parent = vnode._dom = vnode._nextDom = undefined;\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n", "import { EMPTY_OBJ } from './constants';\nimport { commitRoot, diff } from './diff/index';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\nimport { slice } from './util';\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {ComponentChild} vnode The virtual node to render\n * @param {PreactElement} parentDom The DOM element to render into\n * @param {PreactElement | object} [replaceNode] Optional: Attempt to re-use an\n * existing DOM tree rooted at `replaceNode`\n */\nexport function render(vnode, parentDom, replaceNode) {\n\tif (options._root) options._root(vnode, parentDom);\n\n\t// We abuse the `replaceNode` parameter in `hydrate()` to signal if we are in\n\t// hydration mode or not by passing the `hydrate` function instead of a DOM\n\t// element..\n\tlet isHydrating = typeof replaceNode == 'function';\n\n\t// To be able to support calling `render()` multiple times on the same\n\t// DOM node, we need to obtain a reference to the previous tree. We do\n\t// this by assigning a new `_children` property to DOM nodes which points\n\t// to the last rendered tree. By default this property is not present, which\n\t// means that we are mounting a new tree for the first time.\n\tlet oldVNode = isHydrating\n\t\t? null\n\t\t: (replaceNode && replaceNode._children) || parentDom._children;\n\n\tvnode = ((!isHydrating && replaceNode) || parentDom)._children =\n\t\tcreateElement(Fragment, null, [vnode]);\n\n\t// List of effects that need to be called after diffing.\n\tlet commitQueue = [],\n\t\trefQueue = [];\n\tdiff(\n\t\tparentDom,\n\t\t// Determine the new vnode tree and store it on the DOM element on\n\t\t// our custom `_children` property.\n\t\tvnode,\n\t\toldVNode || EMPTY_OBJ,\n\t\tEMPTY_OBJ,\n\t\tparentDom.namespaceURI,\n\t\t!isHydrating && replaceNode\n\t\t\t? [replaceNode]\n\t\t\t: oldVNode\n\t\t\t\t? null\n\t\t\t\t: parentDom.firstChild\n\t\t\t\t\t? slice.call(parentDom.childNodes)\n\t\t\t\t\t: null,\n\t\tcommitQueue,\n\t\t!isHydrating && replaceNode\n\t\t\t? replaceNode\n\t\t\t: oldVNode\n\t\t\t\t? oldVNode._dom\n\t\t\t\t: parentDom.firstChild,\n\t\tisHydrating,\n\t\trefQueue\n\t);\n\n\t// Flush all queued effects\n\tcommitRoot(commitQueue, vnode, refQueue);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {ComponentChild} vnode The virtual node to render\n * @param {PreactElement} parentDom The DOM element to update\n */\nexport function hydrate(vnode, parentDom) {\n\trender(vnode, parentDom, hydrate);\n}\n", "import { assign, slice } from './util';\nimport { createVNode } from './create-element';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its\n * children.\n * @param {VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<ComponentChildren>} rest Any additional arguments will be used\n * as replacement children.\n * @returns {VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\n\tlet defaultProps;\n\n\tif (vnode.type && vnode.type.defaultProps) {\n\t\tdefaultProps = vnode.type.defaultProps;\n\t}\n\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse if (props[i] === undefined && defaultProps !== undefined) {\n\t\t\tnormalizedProps[i] = defaultProps[i];\n\t\t} else {\n\t\t\tnormalizedProps[i] = props[i];\n\t\t}\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\tnull\n\t);\n}\n", "/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {VNode} vnode The vnode that threw the error that was caught (except\n * for unmounting when this parameter is the highest parent that was being\n * unmounted)\n * @param {VNode} [oldVNode]\n * @param {ErrorInfo} [errorInfo]\n */\nexport function _catchError(error, vnode, oldVNode, errorInfo) {\n\t/** @type {Component} */\n\tlet component,\n\t\t/** @type {ComponentType} */\n\t\tctor,\n\t\t/** @type {boolean} */\n\t\thandled;\n\n\tfor (; (vnode = vnode._parent); ) {\n\t\tif ((component = vnode._component) && !component._processingException) {\n\t\t\ttry {\n\t\t\t\tctor = component.constructor;\n\n\t\t\t\tif (ctor && ctor.getDerivedStateFromError != null) {\n\t\t\t\t\tcomponent.setState(ctor.getDerivedStateFromError(error));\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\tif (component.componentDidCatch != null) {\n\t\t\t\t\tcomponent.componentDidCatch(error, errorInfo || {});\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\t// This is an error boundary. Mark it as having bailed out, and whether it was mid-hydration.\n\t\t\t\tif (handled) {\n\t\t\t\t\treturn (component._pendingError = component);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n", "var n=function(t,s,r,e){var u;s[0]=0;for(var h=1;h<s.length;h++){var p=s[h++],a=s[h]?(s[0]|=p?1:2,r[s[h++]]):s[++h];3===p?e[0]=a:4===p?e[1]=Object.assign(e[1]||{},a):5===p?(e[1]=e[1]||{})[s[++h]]=a:6===p?e[1][s[++h]]+=a+\"\":p?(u=t.apply(a,n(t,a,r,[\"\",null])),e.push(u),a[0]?s[0]|=2:(s[h-2]=0,s[h]=u)):e.push(a)}return e},t=new Map;export default function(s){var r=t.get(this);return r||(r=new Map,t.set(this,r)),(r=n(this,r.get(s)||(r.set(s,r=function(n){for(var t,s,r=1,e=\"\",u=\"\",h=[0],p=function(n){1===r&&(n||(e=e.replace(/^\\s*\\n\\s*|\\s*\\n\\s*$/g,\"\")))?h.push(0,n,e):3===r&&(n||e)?(h.push(3,n,e),r=2):2===r&&\"...\"===e&&n?h.push(4,n,0):2===r&&e&&!n?h.push(5,0,!0,e):r>=5&&((e||!n&&5===r)&&(h.push(r,0,e,s),r=6),n&&(h.push(r,n,0,s),r=6)),e=\"\"},a=0;a<n.length;a++){a&&(1===r&&p(),p(a));for(var l=0;l<n[a].length;l++)t=n[a][l],1===r?\"<\"===t?(p(),h=[h],r=3):e+=t:4===r?\"--\"===e&&\">\"===t?(r=1,e=\"\"):e=t+e[0]:u?t===u?u=\"\":e+=t:'\"'===t||\"'\"===t?u=t:\">\"===t?(p(),r=1):r&&(\"=\"===t?(r=5,s=e,e=\"\"):\"/\"===t&&(r<5||\">\"===n[a][l+1])?(p(),3===r&&(h=h[0]),r=h,(h=h[0]).push(2,0,r),r=0):\" \"===t||\"\\t\"===t||\"\\n\"===t||\"\\r\"===t?(p(),r=2):e+=t),3===r&&\"!--\"===e&&(r=4,h=h[0])}return p(),h}(s)),r),arguments,[])).length>1?r:r[0]}\n", "import{h as r,Component as o,render as t}from\"preact\";export{h,render,Component}from\"preact\";import e from\"htm\";var m=e.bind(r);export{m as html};\n", "import { html } from \"htm/preact\";\n\nconst Layout = ({\n  navColor,\n  navLink,\n  children,\n}: {\n  navColor: string;\n  navLink: string;\n  children: unknown;\n}) => {\n  return html`\n    <nav style=${navStyle(navColor)}>\n      <div class=\"container align-center\">\n        <img\n          height=\"200px\"\n          width=\"1000px\"\n          style=\"max-width:100%; margin: 1rem;\"\n          src=\"https://raw.githubusercontent.com/sejori/peko/main/example/preactSSR/assets/logo_dark_alpha.webp\"\n          alt=\"peko-logo\"\n        />\n        <h1 style=\"text-align: center;\">\n          Featherweight <a href=\"/${navLink}\" style=${navLinkStyle}>apps</a>\n        </h1>\n        <h2 style=\"text-align: center;\">on the edge \uD83D\uDC23\u26A1</h2>\n      </div>\n    </nav>\n    <main style=\"padding: 1rem;\" class=\"container\">${children}</main>\n    <footer style=${footerStyle}>\n      <div class=\"container row\">\n        <a style=${footerLinkStyle} href=\"https://github.com/sebringrose/peko\">\n          <img\n            src=\"https://raw.githubusercontent.com/edent/SuperTinyIcons/master/images/svg/github.svg\"\n            width=\"100\"\n            height=\"100\"\n            alt=\"GitHub\"\n          />\n          Source repo\n        </a>\n        <a\n          class=\"align-center\"\n          style=${footerLinkStyle}\n          href=\"https://doc.deno.land/https://deno.land/x/peko/mod.ts\"\n        >\n          <img\n            src=\"https://raw.githubusercontent.com/denolib/high-res-deno-logo/master/deno_hr_circle.svg\"\n            width=\"100\"\n            height=\"100\"\n            alt=\"Deno\"\n          />\n          API docs\n        </a>\n      </div>\n      <div class=\"container row\">\n        <a style=${footerLinkStyle} href=\"/\">Home</a>\n        <a style=${footerLinkStyle} href=\"/about\">About</a>\n      </div>\n      <p style=\"margin: 10px; text-align: center\">\n        Made by <a href=\"https://thesebsite.com\">Sejori</a>\n      </p>\n    </footer>\n  `;\n};\n\nconst navStyle = (navColor: string) => `\n  width: 100%;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  color: white;\n  background-color: ${navColor};\n  padding-bottom: 20px;\n`;\n\nconst navLinkStyle = `\n  color: white;\n`;\n\nconst footerStyle = `\n  padding-top: 20px;\n`;\n\nconst footerLinkStyle = `\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  font-size: 1rem;\n  padding: 0px 5px;\n  margin-bottom: 1rem;\n`;\n\nexport default Layout;\n", "import { html } from \"htm/preact\";\n\nimport Layout from \"../components/Layout.ts\";\n\nconst Home = () => {\n  return html`\n    <${Layout} navLink=\"about\" navColor=\"#101727\">\n      <h2>Features</h2>\n      <ul>\n        <li>Simple and familiar syntax, supports any modern JS/TS environment.</li>\n        <li>Library of request <a href=\"#handlers\">handlers</a>, <a href=\"#middleware\">middleware</a> and <a href=\"#utils\">utils</a>.</li>\n        <li>Cascades <a target=\"_blank\" href=\"https://github.com/sebringrose/peko/blob/main/server.ts\">Request Context</a> through middleware stack for data flow and post-response operations.</li>\n        <li>100% TypeScript complete with tests.</li>\n      </ul>\n\n      <h2>Guides</h2>\n      <ol>\n        <li><a href=\"https://github.com/sebringrose/peko/blob/main/react.md\">How to build a full-stack React application with Peko and Deno</a></li>\n        <li>Want to build a lightweight HTML or Preact app? Check out the <a href=\"https://github.com/sebringrose/peko/blob/main/examples\">examples</a>!</li>\n      </ol>\n\n      <div style=\"display: flex; justify-content: space-between; flex-wrap: wrap;\">\n        <div>\n          <h2 id=\"handlers\">Handlers</h2>\n          <ul>\n            <li><a target=\"_blank\" href=\"https://github.com/sebringrose/peko/blob/main/handlers/ssr.ts\">Server-side render</a></li>\n            <li><a target=\"_blank\" href=\"https://github.com/sebringrose/peko/blob/main/handlers/file.ts\">Static files</a></li>\n            <li><a target=\"_blank\" href=\"https://github.com/sebringrose/peko/blob/main/handlers/sse.ts\">Server-sent events</a></li>\n          </ul>\n        </div>\n\n        <div>\n          <h2 id=\"middleware\">Middleware</h2>\n          <ul>\n            <li><a target=\"_blank\" href=\"https://github.com/sebringrose/peko/blob/main/middleware/authenticator.ts\">JWT verifying</a></li>\n            <li><a target=\"_blank\" href=\"https://github.com/sebringrose/peko/blob/main/middleware/cacher.ts\">Response caching</a></li>\n            <li><a target=\"_blank\" href=\"https://github.com/sebringrose/peko/blob/main/middleware/logger.ts\">Request logging</a></li>\n          </ul>\n        </div>\n\n        <div>\n          <h2 id=\"utils\">Utils</h2>\n          <ul>\n            <li><a target=\"_blank\" href=\"https://github.com/sebringrose/peko/blob/main/utils/Crypto.ts\">Crypto - JWT/hashing</a></li>\n            <li><a target=\"_blank\" href=\"https://github.com/sebringrose/peko/blob/main/utils/Profiler.ts\">Profiler</a></li>\n          </ul>\n        </div>\n      </div>\n    </${Layout}>\n  `;\n};\n\nexport default Home;\n"],
  "mappings": "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",
  "names": ["MODE_HYDRATE", "slice", "options", "vnodeId", "isValidElement", "rerenderQueue", "prevDebounce", "defer", "depthSort", "eventClock", "eventProxy", "eventProxyCapture", "i", "EMPTY_OBJ", "EMPTY_ARR", "IS_NON_DIMENSIONAL", "isArray", "Array", "assign", "obj", "props", "removeNode", "node", "parentNode", "removeChild", "createElement", "type", "children", "key", "ref", "normalizedProps", "arguments", "length", "call", "defaultProps", "createVNode", "original", "vnode", "__k", "__", "__b", "__e", "__d", "__c", "constructor", "__v", "__i", "__u", "Fragment", "props", "children", "BaseComponent", "context", "this", "getDomSibling", "vnode", "childIndex", "__", "sibling", "__k", "length", "__e", "type", "updateParentDomPointers", "i", "child", "__c", "base", "enqueueRender", "c", "__d", "rerenderQueue", "push", "process", "prevDebounce", "options", "debounceRendering", "defer", "renderQueueLength", "component", "newVNode", "oldVNode", "oldDom", "commitQueue", "refQueue", "sort", "depthSort", "shift", "assign", "__v", "diff", "__P", "namespaceURI", "__u", "__i", "commitRoot", "diffChildren", "parentDom", "renderResult", "newParentVNode", "oldParentVNode", "globalContext", "namespace", "excessDomChildren", "isHydrating", "childVNode", "newDom", "firstChildDom", "oldChildren", "EMPTY_ARR", "newChildrenLength", "constructNewChildrenArray", "EMPTY_OBJ", "ref", "applyRef", "contains", "insert", "nextSibling", "skewedIndex", "matchingIndex", "oldChildrenLength", "remainingOldChildren", "skew", "constructor", "String", "createVNode", "isArray", "__b", "key", "findMatchingIndex", "unmount", "parentVNode", "insertBefore", "nodeType", "findMatchingIndex", "childVNode", "oldChildren", "skewedIndex", "remainingOldChildren", "key", "type", "x", "y", "oldVNode", "__u", "length", "setStyle", "style", "value", "setProperty", "IS_NON_DIMENSIONAL", "test", "dom", "name", "oldValue", "namespace", "useCapture", "o", "cssText", "replace", "toLowerCase", "slice", "l", "_attached", "eventClock", "addEventListener", "eventProxyCapture", "eventProxy", "removeEventListener", "e", "removeAttribute", "setAttribute", "createEventProxy", "this", "eventHandler", "_dispatched", "options", "event", "diff", "parentDom", "newVNode", "globalContext", "excessDomChildren", "commitQueue", "oldDom", "isHydrating", "refQueue", "tmp", "c", "isNew", "oldProps", "oldState", "snapshot", "clearProcessingException", "newProps", "isClassComponent", "provider", "componentContext", "i", "renderHook", "count", "renderResult", "newType", "constructor", "__e", "__b", "outer", "props", "prototype", "render", "contextType", "__c", "__", "__E", "BaseComponent", "doRender", "sub", "state", "context", "__n", "__d", "__h", "_sb", "__s", "getDerivedStateFromProps", "assign", "__v", "componentWillMount", "componentDidMount", "push", "componentWillReceiveProps", "shouldComponentUpdate", "__k", "forEach", "vnode", "componentWillUpdate", "componentDidUpdate", "__P", "__r", "getChildContext", "getSnapshotBeforeUpdate", "diffChildren", "isArray", "Fragment", "children", "base", "MODE_HYDRATE", "indexOf", "diffElementNodes", "diffed", "commitRoot", "root", "applyRef", "some", "cb", "call", "newHtml", "oldHtml", "newChildren", "inputValue", "checked", "nodeType", "localName", "document", "createTextNode", "createElementNS", "is", "data", "childNodes", "EMPTY_OBJ", "attributes", "__html", "innerHTML", "getDomSibling", "removeNode", "ref", "current", "unmount", "parentVNode", "skipRemove", "r", "componentWillUnmount", "slice", "EMPTY_ARR", "options", "__e", "error", "vnode", "oldVNode", "errorInfo", "component", "ctor", "handled", "__", "__c", "constructor", "getDerivedStateFromError", "setState", "__d", "componentDidCatch", "__E", "e", "vnodeId", "isValidElement", "undefined", "BaseComponent", "prototype", "update", "callback", "s", "this", "__s", "state", "assign", "props", "__v", "_sb", "push", "enqueueRender", "forceUpdate", "__h", "render", "Fragment", "rerenderQueue", "defer", "Promise", "then", "bind", "resolve", "setTimeout", "depthSort", "a", "b", "__b", "process", "__r", "eventClock", "eventProxy", "createEventProxy", "eventProxyCapture", "i", "n", "s", "r", "e", "u", "h", "p", "a", "t", "htm_module_default", "l", "m", "htm_module_default", "_", "Layout", "navColor", "navLink", "children", "m", "navStyle", "navLinkStyle", "footerStyle", "footerLinkStyle", "Layout_default", "Home", "m", "Layout_default", "Home_default"]
}
