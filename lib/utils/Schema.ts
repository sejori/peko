import { RequestContext } from "../Router";
import { Middleware } from "../types";
export class ID extends String {}
export class Int extends Number {}
export class Float extends Number {}
export const defaultScalars = { ID, Int, Float, Boolean, Date, String };

type Scalars = (typeof defaultScalars)[keyof typeof defaultScalars];
type FieldType = Scalars | Type<Fields>;
interface FieldConfig<T extends FieldType> {
  validator?: (
    x: ResolveType<T>
  ) => boolean | { pass: boolean; message: string };
  resolver?: (x: RequestContext) => Promise<ResolveType<T>[]>;
}
interface InputConfig<F extends Fields> {
  fields: F;
}
interface TypeConfig<F extends Fields> {
  fields: F;
  resolver: (ctx: RequestContext) => Promise<ResolvedFields<F>[]>;
}
interface QueryConfig<I extends Input<Fields>, O extends Type<Fields>> {
  input: I;
  output: O;
  resolver: (
    ctx: RequestContext
  ) => Promise<ResolvedFields<O["config"]["fields"]>[]>;
  middleware?: Middleware[];
}

export class Field<T extends FieldType> {
  constructor(public type: T, public config: FieldConfig<T> = {}) {}
}

type Fields = {
  [key: string]: Field<FieldType>;
};
type ResolvedFields<Fields> = {
  [P in keyof Fields]: Fields[P] extends Field<infer FieldType>
    ? ResolveType<FieldType>
    : never;
};
type ResolveType<T> = T extends Type<infer Fields>
  ? ResolvedFields<Fields>
  : T extends Scalars
  ? InstanceType<T>
  : never;

export class Input<F extends Fields> {
  constructor(public name: string, public config: InputConfig<F>) {}
}

export class Type<F extends Fields> {
  constructor(public name: string, public config: TypeConfig<F>) {}
}

export class Query<I extends Input<Fields>, O extends Type<Fields>> {
  public type = "query";
  constructor(public name: string, public config: QueryConfig<I, O>) {}
}

export class Mutation<
  I extends Input<Fields>,
  O extends Type<Fields>
> extends Query<I, O> {
  public type = "mutation";
}

export class Schema {
  public scalars: Record<string, Function> = {
    ...defaultScalars,
  };

  constructor(
    public operations: Query<Input<Fields>, Type<Fields>>[],
    additionalScalars: Record<string, Function> = {}
  ) {
    Object.keys(additionalScalars).forEach(
      (key) => (this.scalars[key] = additionalScalars[key])
    );
  }

  toString() {
    let schema = "# GraphQL Schema (autogenerated)\n";
    schema += Object.keys(this.scalars)
      .map((key) => `scalar ${key}`)
      .join("\n");
    schema += "\n\n";

    schema += "type Query {\n";
    schema += this.operations
      .filter((query) => query.type == "query")
      .map((query) => `  ${query.name}: ${query.config.output.name}`)
      .join("\n");
    schema += "\n";
    schema += "}\n\n";

    schema += "type Mutation {\n";
    schema += this.operations
      .filter((query) => query.type == "mutation")
      .map((query) => `  ${query.name}: ${query.config.output.name}`)
      .join("\n");
    schema += "\n";
    schema += "}\n\n";

    this.operations.forEach((query) => {
      schema += `input ${query.config.input.name} {\n`;
      schema += Object.entries(query.config.input.config.fields)
        .map((field) => `  ${field[0]}: ${field[1].type.name}`)
        .join("\n");
      schema += "\n";
      schema += "}\n\n";

      schema += `type ${query.config.output.name} {\n`;
      schema += Object.entries(query.config.output.config.fields)
        .map((field) => `  ${field[0]}: ${field[1].type.name}`)
        .join("\n");
      schema += "\n";
      schema += "}\n\n";
    });

    return schema;
  }
}
