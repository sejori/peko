import { SchemaRoute } from "../routers/schemaRouter.ts";
import { RequestContext } from "../types.ts";

export class ID extends String {}
export class Int extends Number {}
export class Float extends Number {}
export class Enum<T extends Record<string, string> = Record<string, string>> {
  constructor(public name: string, public values: T) {}
}
export const defaultScalars = { ID, Int, Float, Boolean, Date, String };

type Scalars = (typeof defaultScalars)[keyof typeof defaultScalars];
type GroupedTypes = Scalars | Enum<Record<string, string>> | DTO<Fields>;
export type FieldType = GroupedTypes | GroupedTypes[];

interface FieldConfig<T extends FieldType> {
  nullable?: boolean;
  validator?: (
    x: ResolvedType<T>
  ) => boolean | { pass: boolean; message: string };
  resolver?: (
    x: RequestContext
  ) => Promise<ResolvedField<Field<T>>[]> | ResolvedField<Field<T>>[];
}
export class Field<T extends FieldType> {
  constructor(public type: T, public config: FieldConfig<T> = {}) {}
}
export interface Fields {
  [key: string]: Field<FieldType>;
}

export class DTO<F extends Fields> {
  constructor(public name: string, public fields: F) {}
}

type ResolvedFields<Fields> = {
  [P in keyof Fields]: ResolvedField<Fields[P]>;
};

export type ResolvedField<T> = T extends Field<infer F>
  ? F extends GroupedTypes[]
    ? ResolvedType<F[0]>[]
    : ResolvedType<F>
  : never;

export type ResolvedType<T> = T extends DTO<infer Fields>
  ? ResolvedFields<Fields>
  : T extends Scalars
  ? InstanceType<T>
  : T extends Enum<Record<string, string>>
  ? T["values"][keyof T["values"]]
  : T extends Array<infer U> // New condition for handling arrays
  ? ResolvedType<U>[]
  : never;

export const generateSchema = ({
  scalars,
  routes,
}: {
  scalars: Record<string, new (...args: unknown[]) => unknown>;
  routes: SchemaRoute<DTO<Fields>>[];
}) => {
  let schema = "# GraphQL Schema (autogenerated)\n\n";
  schema += generateScalarSchema(scalars);
  schema += "\n\n";
  schema += generateEnumSchema(routes);

  schema += "type Query {\n";
  schema += generateOperationsSchema("QUERY", routes);
  schema += "\n}\n\n";

  schema += "type Mutation {\n";
  schema += generateOperationsSchema("MUTATION", routes);
  schema += "\n}\n\n";

  schema += generateDtosSchema(routes);
  schema += "\n\n";

  return schema;
};

export const generateScalarSchema = (
  scalars: Record<string, new (...args: unknown[]) => unknown>
): string => {
  return Object.keys(scalars)
    .map((key) => `scalar ${key}`)
    .join("\n");
};

export const generateEnumSchema = (
  routes: SchemaRoute<DTO<Fields>>[]
): string => {
  const enums = new Set<Enum>();
  let enumsString = "";

  const collectFromFields = (fields: Fields) => {
    Object.values(fields).forEach((field) => {
      if (field instanceof DTO) {
        collectFromFields(field.fields);
      } else {
        const fieldType = field.type;
        if (fieldType instanceof Enum) {
          enums.add(fieldType);
        } else if (Array.isArray(fieldType) && fieldType[0] instanceof Enum) {
          enums.add(fieldType[0]);
        }
      }
    });
  };

  routes.forEach((route) => {
    collectFromFields(route.args);
    if (Array.isArray(route.data)) {
      collectFromFields(route.data[0].fields);
    } else {
      collectFromFields(route.data.fields);
    }
  });

  enums.forEach((enumType) => {
    enumsString += `enum ${enumType.name} {\n`;
    Object.values(enumType.values).forEach((value) => {
      enumsString += `  ${value}\n`;
    });
    enumsString += "}\n\n";
  });

  return enumsString;
};

export const generateOperationsSchema = (
  type: "QUERY" | "MUTATION",
  routes: SchemaRoute<DTO<Fields>>[]
): string => {
  return routes
    .filter((route) => route.method === type)
    .map((route) => {
      const args = Object.entries(route.args)
        .map(([name, field]) => `${name}: ${generateFieldString(field)}`)
        .join(", ");
      const outputType = Array.isArray(route.data)
        ? `[${route.data[0].name}]!`
        : `${route.data.name}!`;
      return `  ${route.path}(${args}): ${outputType}`;
    })
    .join("\n");
};

export const generateDtosSchema = (
  routes: SchemaRoute<DTO<Fields>>[]
): string => {
  const DTOs = new Set<{
    dtoType: "input" | "type";
    dto: DTO<Fields> | DTO<Fields>[];
  }>();
  let dtoString = "";

  routes.forEach((route) => {
    Object.values(route.args).forEach((arg) => {
      if (arg.type instanceof DTO) {
        DTOs.add({ dtoType: "input", dto: arg.type });
      }
    });
    DTOs.add({ dtoType: "type", dto: route.data });
  });

  DTOs.forEach((dto) => {
    dtoString += generateDtoSchema(dto);
  });

  return dtoString;
};

const generateDtoSchema = (input: {
  dtoType: "input" | "type";
  dto: DTO<Fields> | DTO<Fields>[];
}): string => {
  const dtoInput = input.dto;
  const isArray = Array.isArray(dtoInput);
  const dto = isArray ? dtoInput[0] : dtoInput;

  const fieldsString = Object.entries(dto.fields)
    .map(([fieldName, field]) => {
      const fieldTypeString = generateFieldString(field);
      return `  ${fieldName}: ${fieldTypeString}`;
    })
    .join("\n");

  return `${input.dtoType} ${dto.name} {\n${fieldsString}\n}\n\n`;
};

const generateFieldString = (field: Field<FieldType>): string => {
  const isArray = Array.isArray(field.type);
  const baseType = Array.isArray(field.type) ? field.type[0] : field.type;
  const typeName = baseType instanceof DTO ? baseType.name : baseType.name;
  return `${isArray ? `[${typeName}]` : typeName}${
    field.config.nullable ? "" : "!"
  }`;
};
