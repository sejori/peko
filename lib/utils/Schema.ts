import { RequestContext } from "../Router";
import { Middleware } from "../types";

export class ID extends String {}
export class Int extends Number {}
export class Float extends Number {}
export const defaultScalars = { ID, Int, Float, Boolean, Date, String };
export type Scalars = (typeof defaultScalars)[keyof typeof defaultScalars];
export class Enum<T extends Record<string, string>> {
  constructor(public name: string, public values: T) {}
}

type GroupedTypes = Scalars | Enum<Record<string, string>> | Type<Fields>;
type FieldType = GroupedTypes | GroupedTypes[];
type Fields = {
  [key: string]: Field<FieldType>;
};

export class Field<T extends FieldType> {
  constructor(public type: T, public config: FieldConfig<T> = {}) {}
}

interface FieldConfig<T extends FieldType> {
  nullable?: boolean;
  validator?: (
    x: ResolvedType<T>
  ) => boolean | { pass: boolean; message: string };
  resolver?: (x: RequestContext) => Promise<ResolvedField<Field<T>>[]>;
}

type ResolvedFields<Fields> = {
  [P in keyof Fields]: ResolvedField<Fields[P]>;
};

type ResolvedField<T> = T extends Field<infer F>
  ? F extends GroupedTypes[]
    ? ResolvedType<F[0]>[]
    : ResolvedType<F>
  : never;

export type ResolvedType<T> = T extends Type<infer Fields>
  ? ResolvedFields<Fields>
  : T extends Scalars
  ? InstanceType<T>
  : T extends Enum<Record<string, string>>
  ? T["values"][keyof T["values"]]
  : never;

export class DTO<F extends Fields> {
  constructor(public name: string, public config: DTOConfig<F>) {}
}
export class Input<F extends Fields> extends DTO<F> {}
export class Type<F extends Fields> extends DTO<F> {}

interface DTOConfig<F extends Fields> {
  fields: F;
}

export class Query<
  I extends Input<Fields>,
  O extends Type<Fields> | Type<Fields>[]
> {
  public type = "query";
  constructor(public name: string, public config: QueryConfig<I, O>) {}
}

export class Mutation<
  I extends Input<Fields>,
  O extends Type<Fields> | Type<Fields>[]
> extends Query<I, O> {
  public type = "mutation";
}

interface QueryConfig<
  I extends Input<Fields>,
  O extends Type<Fields> | Type<Fields>[]
> {
  input: I;
  output: O;
  resolver: (ctx: RequestContext) => Promise<ResolvedField<Field<O>>>;
  middleware?: Middleware[];
}

export class Schema {
  public scalars: Record<string, Function> = {
    ...defaultScalars,
  };

  constructor(
    public operations: Query<Input<Fields>, Type<Fields> | Type<Fields>[]>[],
    additionalScalars: Record<string, Function> = {}
  ) {
    Object.keys(additionalScalars).forEach(
      (key) => (this.scalars[key] = additionalScalars[key])
    );
  }

  toString() {
    let schema = "# GraphQL Schema (autogenerated)\n";
    schema += Object.keys(this.scalars)
      .map((key) => `scalar ${key}`)
      .join("\n");
    schema += "\n\n";

    schema += "type Query {\n";
    schema += this.operations
      .filter((query) => query.type == "query")
      .map(
        (query) =>
          `  ${query.name}: ${
            query.config.output instanceof Array
              ? query.config.output[0].name
              : query.config.output.name
          }!`
      )
      .join("\n");
    schema += "\n";
    schema += "}\n\n";

    schema += "type Mutation {\n";
    schema += this.operations
      .filter((query) => query.type == "mutation")
      .map(
        (query) =>
          `  ${query.name}: ${
            query.config.output instanceof Array
              ? `[${query.config.output[0].name}]`
              : query.config.output.name
          }!`
      )
      .join("\n");
    schema += "\n";
    schema += "}\n\n";

    this.operations.forEach((query) => {
      schema += `input ${query.config.input.name} {\n`;
      schema += Object.entries(query.config.input.config.fields)
        .map(
          (field) =>
            `  ${field[0]}: ${
              field[1].type instanceof Array
                ? `[${field[1].type[0].name}]`
                : field[1].type.name
            }${field[1].config.nullable ? "" : "!"}`
        )
        .join("\n");
      schema += "\n";
      schema += "}\n\n";

      schema += `type ${
        query.config.output instanceof Array
          ? `${query.config.output[0].name}`
          : query.config.output.name
      } {\n`;
      schema += Object.entries(
        query.config.output instanceof Array
          ? query.config.output[0].config.fields
          : query.config.output.config.fields
      )
        .map(
          (field) =>
            `  ${field[0]}: ${
              field[1].type instanceof Array
                ? `[${field[1].type[0].name}]`
                : field[1].type.name
            }${field[1].config.nullable ? "" : "!"}`
        )
        .join("\n");
      schema += "\n";
      schema += "}\n\n";
    });

    return schema;
  }
}
