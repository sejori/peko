import { RequestContext } from "../Router";
import { Middleware } from "../types";

export class ID extends String {}
export class Int extends Number {}
export class Float extends Number {}
export const defaultScalars = { ID, Int, Float, Boolean, Date, String };
export type Scalars = (typeof defaultScalars)[keyof typeof defaultScalars];
export class Enum<T extends Record<string, string>> {
  constructor(public name: string, public values: T) {}
}

type GroupedTypes = Scalars | Enum<Record<string, string>> | Type<Fields>;
type FieldType = GroupedTypes | GroupedTypes[];
type Fields = {
  [key: string]: Field<FieldType>;
};

export class Field<T extends FieldType> {
  constructor(public type: T, public config: FieldConfig<T> = {}) {}
}

interface FieldConfig<T extends FieldType> {
  nullable?: boolean;
  validator?: (
    x: ResolvedType<T>
  ) => boolean | { pass: boolean; message: string };
  resolver?: (x: RequestContext) => Promise<ResolvedField<Field<T>>[]>;
}

type ResolvedFields<Fields> = {
  [P in keyof Fields]: ResolvedField<Fields[P]>;
};

type ResolvedField<T> = T extends Field<infer F>
  ? F extends GroupedTypes[]
    ? ResolvedType<F[0]>[]
    : ResolvedType<F>
  : never;

export type ResolvedType<T> = T extends Type<infer Fields>
  ? ResolvedFields<Fields>
  : T extends Scalars
  ? InstanceType<T>
  : T extends Enum<Record<string, string>>
  ? T["values"][keyof T["values"]]
  : never;

export class DTO<F extends Fields> {
  constructor(public name: string, public config: DTOConfig<F>) {}
}
export class Input<F extends Fields> extends DTO<F> {}
export class Type<F extends Fields> extends DTO<F> {}

interface DTOConfig<F extends Fields> {
  fields: F;
}

export class Query<
  I extends Input<Fields>,
  O extends Type<Fields> | Type<Fields>[]
> {
  public type = "query";
  constructor(public name: string, public config: QueryConfig<I, O>) {}
}

export class Mutation<
  I extends Input<Fields>,
  O extends Type<Fields> | Type<Fields>[]
> extends Query<I, O> {
  public type = "mutation";
}

interface QueryConfig<
  I extends Input<Fields>,
  O extends Type<Fields> | Type<Fields>[]
> {
  input: I;
  output: O;
  resolver: (ctx: RequestContext) => Promise<ResolvedField<Field<O>>>;
  middleware?: Middleware[];
}

export class Schema {
  public scalars: Record<string, Function> = {
    ...defaultScalars,
  };

  constructor(
    public operations: Query<Input<Fields>, Type<Fields> | Type<Fields>[]>[],
    additionalScalars: Record<string, Function> = {}
  ) {
    Object.keys(additionalScalars).forEach(
      (key) => (this.scalars[key] = additionalScalars[key])
    );
  }

  private collectEnums() {
    const enums = new Set<Enum<any>>();

    const collectFromFields = (fields: Fields) => {
      Object.values(fields).forEach((field) => {
        const fieldType = field.type;
        if (fieldType instanceof Enum) {
          enums.add(fieldType);
        } else if (Array.isArray(fieldType) && fieldType[0] instanceof Enum) {
          enums.add(fieldType[0]);
        }
      });
    };

    this.operations.forEach((operation) => {
      collectFromFields(operation.config.input.config.fields);
      if (Array.isArray(operation.config.output)) {
        collectFromFields(operation.config.output[0].config.fields);
      } else {
        collectFromFields(operation.config.output.config.fields);
      }
    });

    return enums;
  }

  toString() {
    let schema = "# GraphQL Schema (autogenerated)\n";

    // Scalars
    schema += Object.keys(this.scalars)
      .map((key) => `scalar ${key}`)
      .join("\n");
    schema += "\n\n";

    // Enums
    const enums = this.collectEnums();
    enums.forEach((enumType) => {
      schema += `enum ${enumType.name} {\n`;
      Object.values(enumType.values).forEach((value) => {
        schema += `  ${value}\n`;
      });
      schema += "}\n\n";
    });

    // Queries and Mutations
    schema += "type Query {\n";
    schema += this.operations
      .filter((query) => query.type === "query")
      .map(
        (query) =>
          `  ${query.name}: ${
            Array.isArray(query.config.output)
              ? `[${query.config.output[0].name}]`
              : query.config.output.name
          }!`
      )
      .join("\n");
    schema += "\n}\n\n";

    schema += "type Mutation {\n";
    schema += this.operations
      .filter((query) => query.type === "mutation")
      .map(
        (query) =>
          `  ${query.name}: ${
            Array.isArray(query.config.output)
              ? `[${query.config.output[0].name}]`
              : query.config.output.name
          }!`
      )
      .join("\n");
    schema += "\n}\n\n";

    // Input Types and Output Types
    this.operations.forEach((query) => {
      schema += `input ${query.config.input.name} {\n`;
      schema += Object.entries(query.config.input.config.fields)
        .map(
          ([name, field]) =>
            `  ${name}: ${
              Array.isArray(field.type)
                ? `[${field.type[0].name}]`
                : field.type.name
            }${field.config.nullable ? "" : "!"}`
        )
        .join("\n");
      schema += "\n}\n\n";

      const outputType = Array.isArray(query.config.output)
        ? query.config.output[0]
        : query.config.output;

      schema += `type ${outputType.name} {\n`;
      schema += Object.entries(outputType.config.fields)
        .map(
          ([name, field]) =>
            `  ${name}: ${
              Array.isArray(field.type)
                ? `[${field.type[0].name}]`
                : field.type.name
            }${field.config.nullable ? "" : "!"}`
        )
        .join("\n");
      schema += "\n}\n\n";
    });

    return schema;
  }
}
