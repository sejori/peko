/// <reference lib="deno.ns" />

import { ModelInterface } from "../../core/utils/Model.ts";
import { Constructor, FieldInterface } from "../../core/utils/Field.ts";
import { GraphRoute } from "../GraphRouter.ts";
import { QueryOperation } from "./QueryParser.ts";

export class Schema {
  constructor(
    public operations: GraphRoute[] = [],
    public scalars: Record<string, Constructor> = {}
  ) {}

  toString() {
    let schema = "# GraphQL Schema (autogenerated)\n\n";
    schema += this.generateScalars();
    schema += "\n\n";
    // schema += this.generateEnums();

    schema += "type Query {\n";
    schema += this.generateOperationFields("QUERY");
    schema += "\n}\n\n";

    schema += "type Mutation {\n";
    schema += this.generateOperationFields("MUTATION");
    schema += "\n}\n\n";

    schema += this.generateModels();
    schema += "\n\n";

    return schema;
  }

  private generateScalars(): string {
    return Object.keys(this.scalars)
      .map((key) => `scalar ${key}`)
      .join("\n");
  }

  // private generateEnums(): string {
  //   const enums = new Set<Enum>();
  //   let enumsString = "";

  //   const collectFromModelSchema = (schema: ModelSchema) => {
  //     Object.entries(schema).forEach(([_key, value]) => {
  //       if ("schema" in value.type) {
  //         collectFromModelSchema((value as unknown as ModelInterface).schema);
  //       } else if (value) {
  //         const fieldType = value.type;
  //         if (fieldType instanceof Enum) {
  //           enums.add(fieldType);
  //         } else if (Array.isArray(fieldType) && fieldType[0] instanceof Enum) {
  //           enums.add(fieldType[0]);
  //         }
  //       }
  //     });
  //   };

  //   this.operations.forEach((operation) => {
  //     if (operation.config.args) collectFromModelSchema(operation.config.args);
  //     const type = Array.isArray(operation.config.type)
  //       ? operation.config.type[0]
  //       : operation.config.type
  //     if ("schema" in type) collectFromModelSchema(type.schema as ModelSchema)
  //   });

  //   enums.forEach((enumType) => {
  //     enumsString += `enum ${enumType.name} {\n`;
  //     Object.values(enumType.values).forEach((value) => {
  //       enumsString += `  ${value}\n`;
  //     });
  //     enumsString += "}\n\n";
  //   });

  //   return enumsString;
  // }

  private generateOperationFields(type: QueryOperation["type"]): string {
    return this.operations
      .filter((operation) => operation.method === type)
      .map((operation) => {
        const args = operation.config.args 
          ? Object.entries(operation.config.args.schema)
            .map(([name, field]) => `${name}: ${this.generateFieldString(field as FieldInterface<Constructor, boolean>)}`)
            .join(", ")
          : "";

        const outputType = Array.isArray(operation.config.type)
          ? `[${operation.config.type[0].name}]!`
          : `${operation.config.type.name}!`;
        return `  ${operation.path}(${args}): ${outputType}`;
      })
      .join("\n");
  }

  private generateModels(): string {
    const models = new Set<{
      type: "input" | "type";
      model: ModelInterface | ModelInterface[];
    }>();
    let modelString = "";

    this.operations.forEach((operation) => {
      // add operation input types (if model constructors)
      if (operation.config.args) {
        Object.entries(operation.config.args.schema).forEach(([_key, value]) => {
          if ("schema" in (value as FieldInterface<ModelInterface, boolean>).type) {
            models.add({ type: "input", model: (value as FieldInterface<ModelInterface, boolean>).type });
          }
        });
      }

      // add operation result types (if model constructors)
      if ("schema" in operation.config.type) models.add({ type: "type", model: operation.config.type as ModelInterface });
    });

    models.forEach((model) => {
      modelString += this.generateModelFields(model);
    });

    return modelString;
  }

  private generateModelFields(input: {
    type: "input" | "type";
    model: ModelInterface | ModelInterface[];
  }): string {
    const model = Array.isArray(input.model) ? input.model[0] : input.model;

    const fieldsString = Object.entries(model.schema)
      .map(([fieldName, field]) => {
        const fieldTypeString = this.generateFieldString(field as FieldInterface<Constructor, boolean>);
        return `  ${fieldName}: ${fieldTypeString}`;
      })
      .join("\n");

    return `${input.type} ${model.name} {\n${fieldsString}\n}\n\n`;
  }

  private generateFieldString(field: FieldInterface<Constructor, boolean>): string {
    const isArray = Array.isArray(field.type);
    const fieldType = Array.isArray(field.type) ? field.type[0] : field.type;
    return `${isArray ? `[${fieldType.name}]` : fieldType.name}${
      field.opts.nullable ? "" : "!"
    }`;
  }
}